WHITESPACE = _{ " " | "\t" | "\r" | "\n" }

COMMENT = _{ "--" ~ (!NEWLINE ~ ANY)* ~ NEWLINE }

keywords = {
    "var"
  | "const"
  | "unit"
  | "never"
  | "end"
  | "function"
  | "include"
  | "not"
  | "ref"
  | "as"
  | "and"
  | "or"
  | "do"
  | "then"
  | "if"
  | "elseif"
  | "else"
  | "while"
  | "for"
  | "with"
  | "begin"
  | "structure"
  | "variants"
  | "union"
  | "type"
  | "return"
  | "break"
  | "continue"
  | "effect"
  | "try"
  | "handle"
  | "resume"
  | primitive_type
}

identifier = @{ !keywords ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

integer = @{ ("+" | "-")? ~ ASCII_DIGIT+ }

float = @{ ("+" | "-")? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* }

char   = ${ "'" ~ char_c ~ "'" }
char_c =  {
    !("\"" | "\\") ~ ANY
  | "\\" ~ ("'" | "\\" | "0" | "e" | "r" | "t" | "n")
  | "\\" ~ ("x" ~ ASCII_HEX_DIGIT{2})
  | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{6})
}

string = ${ "\"" ~ inner ~ "\"" }
inner  = @{ char_s* }
char_s =  {
    !("\"" | "\\") ~ ANY
  | "\\" ~ ("\"" | "\\" | "0" | "e" | "r" | "t" | "n")
  | "\\" ~ ("x" ~ ASCII_HEX_DIGIT{2})
  | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{6})
}

literal = { integer | float | char | string }

primitive_type = @{
    ("i" | "u") ~ ("8" | "16")
  | ("i" | "u" | "f") ~ ("32" | "64")
  | "usize"
  | "char"
  | "unit"
}

structure_type_entry = { identifier ~ ":" ~ mirisa_type }

structure_type = { "structure" ~ (structure_type_entry ~ ("," ~ structure_type_entry)*)? ~ "end" }

variants_type = { "variants" ~ (identifier ~ ("," ~ identifier)*)? ~ "end" }

union_type = { "union" ~ (structure_type_entry ~ ("," ~ structure_type_entry)*)? ~ "end" }

operation = { identifier ~ "(" ~ (mirisa_type ~ ("," ~ mirisa_type)*)? ~ ")" ~ mirisa_type }

effect = { "effect" ~ identifier ~ (operation ~ ("," ~ operation)*)? ~ "end" }

primary_type = { primitive_type | identifier | structure_type | variants_type | union_type }

pointer = { "*" ~ "const"? }

array_t = { "[" ~ (integer)? ~ "]" }

type_modifier = _{ pointer+ | array_t+ }

mirisa_type = { type_modifier? ~ primary_type }

array = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }

structure_entry = { identifier ~ "=" ~ expression }

structure = { "structure" ~ (structure_entry ~ ("," ~ structure_entry)*)? ~ "end" }

union = { "union" ~ structure_entry ~ "end" }

primary_expression = _{ literal | identifier | array | structure | union | "(" ~ expression ~ ")" }

call = { "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

indexing = { "[" ~ expression ~ "]" }

field_access = { "." ~ identifier }

field_dereference = { "->" ~ identifier }

dereference = { "." ~ "*" }

expression_postfix = { call | indexing | dereference }

expression_level_bottom = { primary_expression ~ expression_postfix* }

op_level_prefix = { "not" | "ref" }

expression_level_prefix = { op_level_prefix* ~ expression_level_bottom }

expression_level_as = { expression_level_prefix ~ ("as" ~ mirisa_type)* }

op_level_mul = { "*" | "/" | "%" }

expression_level_mul = { expression_level_as ~ (op_level_mul ~ expression_level_as)* }

op_level_add = { "+" | "-" }

expression_level_add = { expression_level_mul ~ (op_level_add ~ expression_level_mul)* }

op_level_comp = { "=" | "/=" | ("<" | ">") ~ "="? }

expression_level_comp = { expression_level_add ~ (op_level_comp ~ expression_level_add)* }

expression_level_and = { expression_level_comp ~ ("and" ~ expression_level_comp)* }

expression_level_or = { expression_level_and ~ ("or" ~ expression_level_and)* }

expression = _{ expression_level_or }

include = { "include" ~ include_path }

declaration_type = { "const" | "var" }

declaration = { declaration_type ~ identifier ~ ":" ~ mirisa_type ~ ("=" ~ expression)? }

type_declaration = { "type" ~ identifier ~ "=" ~ mirisa_type }

op = _{ op_level_add | op_level_mul }

reassignment_op = @{ (op | ":") ~ "=" }

reassignment_postfix = _{ indexing | dereference | field_access | field_dereference }

lexpression = { identifier ~ reassignment_postfix* | "(" ~ lexpression ~ ")" }

reassignment = { lexpression ~ reassignment_op ~ expression }

body = { statement* }

if_then = { "then" ~ body }

if_elseif = { "elseif" ~ expression ~ "then" ~ body }

if_else = { "else" ~ body }

mirisa_if = {
    "if" ~ expression ~ if_then ~ if_elseif* ~ if_else? ~ "end"
}

mirisa_while = {
    "while" ~ expression ~ "do" ~ body ~ "end"
}

mirisa_for = {
    "for" ~ statement? ~ "while" ~ expression? ~ "with" ~ statement? ~ "do" ~ body ~ "end"
}

handler_args = { (identifier ~ ("," ~ identifier)*)? }

operation_handler = {
    identifier ~ "(" ~ handler_args ~ ")" ~ body ~ "end"
}

handler = { "handle" ~ identifier ~ operation_handler* }

try = { "try" ~ body ~ handler+ ~ "end" }

block = { "begin" ~ body ~ "end" }

mirisa_return = { "return" ~ expression }

statement = {
    declaration
  | type_declaration
  | reassignment
  | mirisa_if
  | mirisa_while
  | mirisa_for
  | try
  | block
  | expression
  | mirisa_return
  | "break"
  | "continue"
}

function_arg = { identifier ~ ":" ~ mirisa_type }

function_args = { (function_arg ~ ("," ~ function_arg)*)? }

effect_set = { ("&" ~ "{" ~ (identifier ~ ("," ~ identifier)*)? ~ "}")? }

function = {
    "function" ~ identifier ~ "(" ~ function_args ~ ")" ~ mirisa_type ~ effect_set ~ "do" ~ body ~ "end"
}

include_path = ${ (ASCII_ALPHANUMERIC | "\\ ")+ ~ ("/" ~ (ASCII_ALPHANUMERIC | "\\ ")+)* }

item = _{ include | declaration | type_declaration | effect | function }

program = _{ SOI ~ item* ~ &EOI }
